// 训练
        // 读取左目训练图像
        while(getline(fTrainL, fileName)) {
            Mat img = imread(fileName);
            trainSetL.push_back(img);
        }
        trainImgSize = trainSetL[0].size();
        trainImgCount = trainSetL.size();
        // 读取右目训练图像
        while(getline(fTrainR, fileName)) {
            Mat img = imread(fileName);
            trainSetR.push_back(img);
        }

        // 用于保存所有图像的匹配点
        vector<vector<Point2f>> allCorrPointsL, allCorrPointsR;
        // 训练图像中的目标真实距离
        vector<float> groundTruth(trainImgCount);
        // 所有匹配点组数
        int corrPointsCount = 0;

        for(int i = 0; i < trainImgCount; i++) {
            //// 中值滤波
            //medianBlur(trainSetL[i], tempEnhanceL, 3);
            //medianBlur(trainSetR[i], tempEnhanceR, 3);
            //trainSetL[i] = tempEnhanceL.clone();
            //trainSetR[i] = tempEnhanceR.clone();

            // 畸变矫正
            if(doDistortionCorrect) {
                undistort(trainSetL[i].clone(), trainSetL[i], cameraMatrixL, distCoeffsL);
                undistort(trainSetR[i].clone(), trainSetR[i], cameraMatrixR, distCoeffsR);
            }

            if(doEnhance) {
                // CLAHE增强
                procCLAHE(trainSetL[i], tempEnhanceL, clipL / 10.0, Size(gridXL, gridYL));
                procCLAHE(trainSetR[i], tempEnhanceR, clipR / 10.0, Size(gridXR, gridYR));
                namedWindow("enhance_leftcam");
                createTrackbar("Clip", "enhance_leftcam", &clipL, MAX_CLIP_LIMIT, onEnhanceTrackbarL_Train, (void *)&i);
                createTrackbar("Grid X", "enhance_leftcam", &gridXL, MAX_GRID_SIZE_X, onEnhanceTrackbarL_Train, (void *)&i);
                createTrackbar("Grid Y", "enhance_leftcam", &gridYL, MAX_GRID_SIZE_Y, onEnhanceTrackbarL_Train, (void *)&i);
                setMouseCallback("enhance_leftcam", onEnhanceMouseL_Train, (void *)&i);
                imshow("enhance_leftcam", tempEnhanceL);

                namedWindow("enhance_rightcam");
                createTrackbar("Clip", "enhance_rightcam", &clipR, MAX_CLIP_LIMIT, onEnhanceTrackbarR_Train, (void *)&i);
                createTrackbar("Grid X", "enhance_rightcam", &gridXR, MAX_GRID_SIZE_X, onEnhanceTrackbarR_Train, (void *)&i);
                createTrackbar("Grid Y", "enhance_rightcam", &gridYR, MAX_GRID_SIZE_Y, onEnhanceTrackbarR_Train, (void *)&i);
                setMouseCallback("enhance_rightcam", onEnhanceMouseR_Train, (void *)&i);
                imshow("enhance_rightcam", tempEnhanceR);

                cout << "增强图像" << endl << endl;
                waitKey();
            }

            imshow("train_leftcam", trainSetL[i]);
            imshow("train_rightcam", trainSetR[i]);
            // 逐图像选取ROI
            setMouseCallback("train_leftcam", onMouseL_ROI_Train, (void *)&i);
            setMouseCallback("train_rightcam", onMouseR_ROI_Train, (void *)&i);
            cout << "在第" << i + 1 << "组图像中各选择一个ROI进行特征匹配：" << endl;
            waitKey();
            cout << "ROI中心：L(" << targetL.x << ", " << targetL.y << ")   ";
            cout << "R(" << targetR.x << ", " << targetR.y << ")" << endl;
            cout << "ROI大小：L(" << roiL.width << ", " << roiL.height << ")   ";
            cout << "R(" << roiR.width << ", " << roiR.height << ")" << endl;
            cout << ">>>>>>>>>>>>>>>>>>>>>>>>" << endl;

            vector<vector<KeyPoint>> keyPoints4All;
            vector<Mat> descriptor4All;
            vector<vector<Vec3b>> colors4All;
            vector<DMatch> matches;
            vector<Mat> rois = { roiImgL, roiImgR };

            switch(type) {
            case SIFT:
                // 局部特征匹配
                extractSIFTFeatures(rois, keyPoints4All, descriptor4All, colors4All);
                matchSIFTFeatures(descriptor4All[0], descriptor4All[1], matches);
                getMatchedPoints(keyPoints4All[0], keyPoints4All[1], matches, objectPointsL, objectPointsR);
                getMatchedColors(colors4All[0], colors4All[1], matches, objectColorsL, objectColorsR);
                break;
            case GMS:
                gmsMatch(roiImgL, roiImgR, objectPointsL, objectPointsR);
                break;
            default:
                break;
            }

            if(objectPointsL.size() == 0) {
                cout << "没有找到匹配点，手动选择一组" << endl;
                imshow("train_leftcam", trainSetL[i]);
                imshow("train_rightcam", trainSetR[i]);
                // 手动选择一组点
                targetL = Point(0, 0);
                targetR = Point(0, 0);
                setMouseCallback("train_leftcam", onMouseL_Train, (void *)&i);
                setMouseCallback("train_rightcam", onMouseR_Train, (void *)&i);
                cout << "在第" << i + 1 << "组图像中各选择一个匹配点：" << endl;
                waitKey();
                cout << "目标点：L(" << targetL.x << ", " << targetL.y << ")   ";
                cout << "R(" << targetR.x << ", " << targetR.y << ")" << endl;
                cout << ">>>>>>>>>>>>>>>>>>>>>>>>" << endl;
                objectPointsL.clear();
                objectPointsR.clear();
                objectPointsL.push_back(targetL);
                objectPointsR.push_back(targetR);
            } else {
                // 将ROI坐标恢复到原图像中
                for(int i = 0; i < objectPointsL.size(); i++) {
                    objectPointsL[i] += Point2f(roiL.x, roiL.y);
                    objectPointsR[i] += Point2f(roiR.x, roiR.y);
                }
            }

            // 保存匹配点
            allCorrPointsL.push_back(objectPointsL);
            allCorrPointsR.push_back(objectPointsR);
            corrPointsCount += objectPointsL.size();

            // 重建坐标
            reconstruct(cameraMatrixL, cameraMatrixR, R, T,
                        objectPointsL, objectPointsR, structure);
            toPoints3D(structure, structure3D);
            // 中位线距离
            dist = ranging(structure3D, R, T);

            // 输出距离
            if(dist.size() > 1 && processRange) {
                // 对求出的距离取中位数
                int len = dist.size();
                if(len % 2) {
                    cout << "目标距离 " << (dist[len / 2 - 1] + dist[len / 2]) / 2 << " m" << endl;
                } else {
                    cout << "目标距离 " << dist[len / 2] << " m" << endl;
                }
            } else {
                for(auto iter = dist.cbegin(); iter < dist.cend(); ++iter) {
                    cout << "目标距离 " << *iter << " m" << endl;
                }
                cout << endl;
            }
            cout << endl;
            waitKey();

            // 记录ground truth
            cout << "输入测距点实际距离： ";
            cin >> groundTruth[i];
            cout << endl;

            destroyAllWindows();
        }

        // 记录所有训练图像的匹配点坐标
        saveCorrspondingPoints("CorrPoints.yaml", cameraMatrixL, cameraMatrixR, R, T, allCorrPointsL, allCorrPointsR, corrPointsCount, groundTruth);
        cout << "已记录所有匹配点坐标，训练完成后回车继续" << endl;
        waitKey();

        cout << "输入训练后的参数：" << endl;
        cout << "K1 = " << endl;
        cin >> cameraMatrixL.at<double>(0, 0) >> cameraMatrixL.at<double>(0, 1) >> cameraMatrixL.at<double>(0, 2);
        cin >> cameraMatrixL.at<double>(1, 0) >> cameraMatrixL.at<double>(1, 1) >> cameraMatrixL.at<double>(1, 2);
        cin >> cameraMatrixL.at<double>(2, 0) >> cameraMatrixL.at<double>(2, 1) >> cameraMatrixL.at<double>(2, 2);
        cout << "K2 = " << endl;
        cin >> cameraMatrixR.at<double>(0, 0) >> cameraMatrixR.at<double>(0, 1) >> cameraMatrixR.at<double>(0, 2);
        cin >> cameraMatrixR.at<double>(1, 0) >> cameraMatrixR.at<double>(1, 1) >> cameraMatrixR.at<double>(1, 2);
        cin >> cameraMatrixR.at<double>(2, 0) >> cameraMatrixR.at<double>(2, 1) >> cameraMatrixR.at<double>(2, 2);
        cout << "R = " << endl;
        cin >> R.at<double>(0, 0) >> R.at<double>(0, 1) >> R.at<double>(0, 2);
        cin >> R.at<double>(1, 0) >> R.at<double>(1, 1) >> R.at<double>(1, 2);
        cin >> R.at<double>(2, 0) >> R.at<double>(2, 1) >> R.at<double>(2, 2);
        cout << endl << "t = " << endl;
        cin >> T.at<double>(0, 0) >> T.at<double>(1, 0) >> T.at<double>(2, 0);